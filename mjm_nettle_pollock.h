#ifndef MJM_NETTLE_POLLOCK_H__
#define MJM_NETTLE_POLLOCK_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"

#include <openssl/ssl.h>
#include <openssl/err.h>

#include "mjm_nettle_creds.h"
//#include "mjm_nettle_pipe.h"
//#include "mjm_nettle_server.h"
#include "mjm_nettle_thread.h"
#include "mjm_ya_buffer.h"
//#include "mjm_nettle_sock_in.h"
//#include "mjm_nettle_sock_out.h"
#include "mjm_nettle_sock_info.h"
#include "mjm_nettle_sock_funcs.h"
#include "mjm_nettle_saver.h"
#include "mjm_nettle_io.h"
#include "mjm_pollfds.h"
#include "mjm_ya_hex_dump.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

// https://www.ibm.com/docs/en/i/7.4?topic=designs-using-poll-instead-select

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <errno.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2025 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Talking Rock GA 30175 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_nettle_pollock.h},
  url = {},
  version = {0.0.0},
  date-started={2025-04-06},
}
*/

// Sun 06 Apr 2025 11:42:05 AM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_nettle_pollock   
// QUICKCOMPILE  g++  -MMD -MF mjm_nettle_pollock.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_NETTLE_POLLOCK -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_nettle_pollock.h  -o mjm_nettle_pollock.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_nettle_pollock("mjm_nettle_pollock" , "https://www.ibm.com/docs/en/i/7.4?topic=designs-using-poll-instead-select");

template <class Tr>
class mjm_nettle_pollock 
{
 typedef mjm_nettle_pollock Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;

typedef mjm_nettle_creds<Tr> Creds;
typedef mjm_nettle_sock_info<Tr> SockInfo; 
typedef mjm_ya_buffer<Tr> Que;
typedef mjm_nettle_sock_funcs<Tr> Funcs; 
typedef mjm_pollfds<Tr> FdsArray;
typedef mjm_nettle_thread<Tr,Myt> PollingThread;

typedef std::map<int,SockInfo> SockMap;
typedef mjm_ya_hex_dump<Tr> YaHex; 
typedef mjm_nettle_saver<Tr> Saver;
typedef mjm_nettle_io<Tr> NettleIO;

class _pipe  
{

public:
_pipe() {Init_pipe(); } 
~_pipe() {Free_pipe(); } 

_pipe(const Line & l,  const IdxTy first ) { Init_pipe(l,first); }
_pipe(const StrTy & s,  const IdxTy flags ) { Init_pipe(s,flags); }
_pipe(const StrTy & s, Creds* p_c,  const IdxTy flags ) { Init_pipe(s,p_c,flags); }
//Pipe p(sin,&cred,nio,flags);
_pipe(const StrTy & s, Creds* p_c,  NettleIO * nio, const IdxTy flags ) { Init_pipe(s,p_c,nio,flags); }
_pipe(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_pipe(r,first,i0,flags); } 
bool encrypt_in() const { return (m_creds!=0)&&(Bit(enc_in,0));} 
bool encrypt_out() const { return (m_creds!=0)&&(Bit(enc_out,0));} 
// do not make server listen 
bool inbound_nio() const { return m_inbound_nio; }
// do not make outbound conn
bool outbound_nio() const { return m_outbound_nio; }
 
StrTy save( const IdxTy flags=0) const { return Save_pipe(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_pipe(flags); } 
void setup(SockInfo & si ) const { Setup(si); } 
private:
void Init_pipe(const StrTy & s,  const IdxTy flags ) 
{ Init_pipe(); 
BaseParams kvp(s);

}
void Init_pipe(const StrTy & s,   Creds* p_c, const IdxTy flags ) 
{ 

Init_pipe(); 
m_creds=p_c;
BaseParams kvp(s);
kvp.get(enc_in,"encin");
kvp.get(enc_out,"encout");
kvp.get(port_in,"portin");
kvp.get(port_out,"portout");
kvp.get(ip_in,"ipin");
kvp.get(ip_out,"ipout");
MM_ERR(" created pipe " << MMPR(dump()))

}


void Init_pipe(const Line & l,  const IdxTy first ) 
{ 
Init_pipe();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_pipe

void Init_pipe(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_pipe();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 
} // Init_pipe

StrTy Save_pipe( const IdxTy flags=0) const  
{
StrTy s;
BaseParams kvp();
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dump_pipe( const IdxTy flags=0) const  
{
Ss ss;
// ss<<MMPR4(); 
ss<<MMPR4(ip_in, ip_out, port_in, port_out);
if (m_creds) ss<<MMPR( m_creds->dump());
ss<<MMPR3( enc_in,enc_out,m_pnio); 
return ss.str(); 
} // Dump 


void Free_pipe()
{

} // Free_pipe
void Init_pipe(const StrTy & s, Creds* p_c,  NettleIO * nio, const IdxTy flags ) 
{ 
//Init_pipe(s,p_c,nio,flags); 
//void Init_pipe(const StrTy & s,   Creds* p_c, const IdxTy flags ) 
Init_pipe(s,p_c,flags);
m_pnio=nio;
if (m_pnio) if (ip_in.length()==0) m_inbound_nio=true;
if (m_pnio) if (ip_out.length()==0) m_outbound_nio=true;
// now determine if anything to do 
}

void Init_pipe()
{
port_in=BAD;
port_out=BAD;
m_creds=0;
enc_in=1;
enc_out=1;
m_pnio=0;
m_inbound_nio=false;
m_outbound_nio=false;
} // Init_pipe

// _pipeMEMBERS

void Setup(SockInfo & si ) const { 
si.ip_in=ip_in;
si.ip_out=ip_out;
si.port_in=port_in;
si.port_out=port_out;
si.m_creds=m_creds;
si.enc_in=enc_in;
si.enc_out=enc_out;
si.m_pnio=m_pnio;
 }  // Setup

public:
// in is server listen port, out is outound conn 
StrTy ip_in, ip_out;
IdxTy port_in, port_out;
Creds * m_creds;
IdxTy enc_in,enc_out; 
NettleIO * m_pnio;
bool m_inbound_nio,m_outbound_nio;
}; // _pipe

 class _sock_drawer  
{

public:
_sock_drawer() {Init_sock_drawer(); } 
~_sock_drawer() {Free_sock_drawer(); } 

_sock_drawer(const Line & l,  const IdxTy first ) { Init_sock_drawer(l,first); }
_sock_drawer(const StrTy & s,  const IdxTy flags ) { Init_sock_drawer(s,flags); }
_sock_drawer(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_sock_drawer(r,first,i0,flags); } 
IdxTy size() const { return m_sock_map.size(); } 
bool has( const int n ) const { return m_sock_map.find(n)!=m_sock_map.end(); } 
SockInfo & get(const int n) 
{
auto ii=m_sock_map.find(n);
if (ii!=m_sock_map.end())
{ return (*ii).second; }

MM_DIE(" dust to dust"<<MMPR(n))
MM_ERR(" making default sock for "<<MMPR(n)) 
return m_sock_map[n]; 
//throw " no sock "<<MMPR(n);

} // get
void set(const SockInfo & si ) { 
if (si.sock()<0)
{
MM_ERR(" attempt to add bad sock danger will robinson "<<MMPR(si.dump()))
MM_DIE(" dust to dust")
} 

m_sock_map[si.sock()]=si; 

}

void clean( FdsArray  & fds, const IdxTy flags )
{
const bool norm_err=Bit(flags,0);
FdsArray & m_fds=fds;
m_fds.clear();
std::vector<int> dvec;
//MM_LOOP(ii,m_socks)
MM_LOOP(ii,m_sock_map)
{
auto & si=(*ii).second;
IdxTy sock=(*ii).first;
if (sock<0) { dvec.push_back(sock); continue; }
if (si.doa()) { dvec.push_back(sock); continue; }
if (si.listen()) { m_fds.add_listen(sock); continue; }
if (si.in()) { m_fds.add_input(sock); continue; }
if (si.out()) { m_fds.add_output(sock); continue; }
MM_ERR(" fall through "<<MMPR2(sock,si.dump()))
} // ii 
//MM_ERR(" done with soxx")
MM_LOOP(ii,dvec) { 

//const auto jj=(m_socks.find((*ii))); 
const auto jj=(m_sock_map.find((*ii))); 
//if (jj!=m_socks.end()) m_socks.erase(jj); 
if (jj!=m_sock_map.end()) 
{ 
auto & s=(*jj).second; 
s.shutdown();   
// TODO should also see if mate is alive and then wait for que empty 
const bool ok_to_drop=s.empty()||!s.nio_keep(); 
if (ok_to_drop) m_sock_map.erase(jj);  
} 
else { MM_ERR(" wtffff "<<MMPR(*ii)) }
}
//MM_ERR(" done with soxx erase ")
if (dvec.size()) 
//{if (m_norm_err){ MM_ERR( " new fds "<<MMPR2(m_sock_drawer.size(),dvec.size()))} }
{if (norm_err){ MM_ERR( " new fds "<<MMPR2(m_sock_map.size(),dvec.size()))} }


} // clean 
void shutdown()
{
MM_LOOP(ii,m_sock_map) { (*ii).second.shutdown(); } 
m_sock_map.clear();
} // shutdown

SockMap & map() { return m_sock_map;}
const SockMap & map() const  { return m_sock_map;}



StrTy save( const IdxTy flags=0) const { return Save_sock_drawer(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_sock_drawer(flags); } 
private:
void Init_sock_drawer(const StrTy & s,  const IdxTy flags ) 
{ Init_sock_drawer(); 
BaseParams kvp(s);

}
void Init_sock_drawer(const Line & l,  const IdxTy first ) 
{ 
Init_sock_drawer();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_sock_drawer

void Init_sock_drawer(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_sock_drawer();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_sock_drawer

StrTy Save_sock_drawer( const IdxTy flags=0) const  
{
StrTy s;
BaseParams kvp();
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dump_sock_drawer( const IdxTy flags=0) const  
{
Ss ss;
// ss<<MMPR4(); 
return ss.str(); 
} // Dump 


void Free_sock_drawer()
{

} // Free_sock_drawer
void Init_sock_drawer()
{

} // Init_sock_drawer

// _sock_drawerMEMBERS
SockMap m_sock_map; 
}; // _sock_drawer

typedef _sock_drawer SockDrawer;

typedef _pipe Pipe;
//typedef std::map<IdxTy, Pipe> PipeMap;
typedef std::map<StrTy, Pipe> PipeMap;

// API

public:
mjm_nettle_pollock() {Init(); }
mjm_nettle_pollock(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_nettle_pollock(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
// thread entry point
IdxTy  start() {PollingLoop(); return 0; }
// called by user seeking to launch accept thread 
IdxTy  launch(const StrTy & s, const IdxTy flags=0 ) {Launch(s); return 0; }
IdxTy size() const { return m_size; }
// no ctor for this no init() use to add pipes
void load(const StrTy & sin,Creds & cred, const IdxTy flags) {Init(sin,cred, flags); }
void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
void dumper_active(const bool a) { m_dumper.active(a); } 
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

void add_pipe(const StrTy & sin, NettleIO * nio, const IdxTy flags)
{
Pipe p(sin,0,nio,flags);
Add(p,sin,flags);
}
void add_pipe(const StrTy & sin, Creds & cred, NettleIO * nio, const IdxTy flags)
{
//BaseParams kvp(sin);
Pipe p(sin,&cred,nio,flags);
Add(p,sin,flags);
} // add_pipe 


StrTy xxx_test(const StrTy & sin, const IdxTy flags) 
{ return XXX_test(sin,flags); } 
~mjm_nettle_pollock() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
StrTy stats(const StrTy & sin,const IdxTy flags) {return Stats(sin,flags); }
private:
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=((~1)<<b); }
static void ClearBit(int& f, const IdxTy b) { f=f&~b; }


StrTy Dump(const IdxTy flags=0) {Ss ss; 
//ss<<MMPR4(m_size, m_fds.size(),m_socks.size(),m_thread.dump());
ss<<MMPR4(m_size, m_fds.size(),m_sd.size(),m_thread.dump());
ss<<MMPR4(m_pipes.size(),m_mu_sleep,m_done,m_flow_msg);
ss<<MMPR(m_norm_err);
//IdxTy m_size; FdsArray m_fds; SockMap m_socks; PollingThread m_thread; PipeMap m_pipes; IdxTy m_mu_sleep; bool m_done; Funcs m_funcs; YaHex m_dumper; bool m_flow_msg,m_norm_err;


 return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
StrTy XXX_test(const StrTy & sin, const IdxTy flags) 
{
StrTy sout="";
MM_ERR(MMPR3(sin,flags,sout))
BaseParams kvp(sin);

return sout;
} // XXX_test

IdxTy  Launch(const StrTy & s) { 
m_thread.launch();
return 0; 

} //Launch 
enum {ERRMASK=POLLRDHUP|POLLHUP|POLLERR|POLLNVAL};
enum {ERRMASKX=POLLHUP|POLLERR|POLLNVAL};
void NoteEvents(int sock, int e)
{
{
Ss ss; ss<<std::hex<<e<<" still not zero ";
MM_ONCE(MMPR(m_fds.event_str(~0)),); 
MM_ERR(MMPR2(sock,m_fds.event_str(e))<< ss.str());
} 

}// NoteEvents 
//launched thread runs here 
IdxTy PollingLoop()
{
SetupServers();
int rc=0;
int timeout=0; 
const int errmask=ERRMASK;
const int errmaskx=ERRMASKX;
const int ePOLLIN=POLLIN|POLLRDNORM;
const int ePOLLOUT=POLLOUT|POLLWRNORM;
// keep things stable from ui during this time 
EnterSerial(0);
while (true)
{
// I think poll wan be sigged which may be more efficient than const waking 
ExitSerial(0);
// hopefully this can not throw lol 
try { usleep(m_mu_sleep); } catch (...) {}
// the que's probably don't need syncronization now... 
EnterSerial(0);
if (m_done){ MM_ERR(" Poll loop exists on m_done ")  break; } 
FixFdss();
 rc = poll(m_fds.fdss(), m_fds.n(), timeout);
    if (rc < 0) { MM_ERR("  poll() failed"<<MMPR2(rc,m_funcs.eText())); break; }
// FIXME now need short timeout to poll other crap if nothing active
// longer timeout or sleep... 
// don't want continue here now but jump to NettleIO or poll that first
// continue doesn't save much either. 
if (rc==0) continue;
// find the active fd's for read and accept and write 
std::vector<int> v;
m_fds.non_zeds(v,rc);
//if (m_flow_msg) { MM_ERR(" events "<<MMPR2(m_fds.n(),v.size())) } 
MM_LOOP(ii,v)
{
//MM_ERR(MMPR(*ii))
auto & fds=m_fds.fdss()[*ii];
int sock=fds.fd;
int e=fds.revents;
// no nconst as status may change 
SockInfo & si= m_sd.get(sock); // m_socks[sock];
if (e&errmask)
{
if (m_norm_err) { MM_ERR("MAYBE ERRORS "<<MMPR2(sock,m_fds.event_str(e))) } 
}
if (e&errmaskx)
{
if (m_norm_err) { MM_ERR("ERRORS "<<MMPR2(sock,m_fds.event_str(e))) } 
si.set_doa();
} // errmask 
else if (si.listen())
{
if (e&ePOLLIN) { Accepts(sock); ClearBit(e,ePOLLIN);}
if (e) NoteEvents(sock,e);
} // listen
else if (si.in())
{
//MM_ERR(" event on in sock ")
if (e&ePOLLIN) { Inputs(sock); ClearBit(e,ePOLLIN); }
if (e&ePOLLOUT) { Outputs(sock); ClearBit(e,ePOLLOUT); }
if (e) NoteEvents(sock,e);
} // input
else if (si.out())
{
if (e&ePOLLIN) { Inputs(sock); ClearBit(e,ePOLLIN); }
if (e&ePOLLOUT) { Outputs(sock); ClearBit(e,ePOLLOUT); }
if (e) NoteEvents(sock,e);
} // out
else MM_ERR(" bad sockinfo "<<MMPR4(sock,*ii,m_fds.event_str(e),si.dump()))
fds.revents=0;
} // ii 
//MM_ERR(" ii loop done") 
} // true

// forgot to close all socks although maybe not?
m_sd.shutdown();

ExitSerial(0);
return 0;
} // PollingLoop 
IdxTy Accepts(const int sock)
{
if (m_flow_msg) { MM_ERR(" accept conn ") } 
//while (true)
        {
if (m_flow_msg) { MM_ERR("  accept lookp  "<<MMPR(sock)) } 
// not rer will update this 
// speculative but usually connects so ok 
//SockInfo si=m_socks[sock];
SockInfo si=m_sd.get(sock);
          int new_sd =m_funcs.accept(sock,si);  
          if (new_sd < 0)
          {
            if (errno != EWOULDBLOCK)
            {	MM_ERR(" bad accept "<<MMPR2(si.dump(), m_funcs.eText())) 
			//	m_socks[sock].set_doa();            
				m_sd.get(sock).set_doa();            
			}
            return 0; 
          }
IdxTy pos=m_fds.add_input(new_sd);
if (m_flow_msg) { MM_ERR(MMPR4(__FUNCTION__,sock,new_sd,si.sock())<<MMPR(pos)) } 
// TODO FIXME this should probably be offline could halt everything doh ... 
//pickup pipe and cred into 
// need to create output sock and fwd and rev que's
si.sock(new_sd);
//m_socks[new_sd]=si;
m_sd.set(si);
if (!si.nio()) {
// open output end of the sock pipe...
int clsock=m_funcs.connect(si);
Mate(clsock, new_sd,si);
}
} // while 
return 0; 
} // Accepts

// new remote connection clsock is destination for new_sd
// incoming conn 
void Mate(int clsock, int new_sd, SockInfo & si )
{
if (clsock>0){
// m_socks[clsock]=si; m_socks[clsock].mate(new_sd); m_socks[new_sd].mate(clsock);
m_sd.set(si); SockInfo & sin=m_sd.get(clsock); sin.mate(new_sd); 
m_sd.get(new_sd).mate(clsock); 
// TODO these do nothing now as its fixed at end 
IdxTy pos=m_fds.add_output(clsock);
if (m_flow_msg) { MM_ERR(" remote established "<<MMPR2(clsock,pos))}
}
else MM_ERR(" remote connect failed ")

} // Mate

////////////////////////////////////////////
IdxTy Inputs(const int sock)
{
if (m_flow_msg){ MM_ERR(" inputs "<<MMPR(sock))}
//MM_ERR(" inputs "<<MMPR(sock)) 
//char buffer[1<<14];
SockInfo& si=m_sd.get(sock); // m_socks[sock];

bool is_nio=si.nio();
if (is_nio) return InputsNio(sock,si);
return InputsMate(sock,si);
}
IdxTy InputsNio(const IdxTy sock, SockInfo & si)
{
NettleIO * pnio=si.pnio();
//auto & q=pnio->que();
int rct=9; 

StrTy xfer=m_funcs.peer(sock)+"..."+pnio->dump();
if (m_flow_msg){ MM_ERR(" inputs "<<MMPR(xfer))}

//MM_ERR(" input  conn ")
while ( true)
//do 
{
auto & q=si.m_que;
IdxTy max=q.space();
//MM_ERR(" fick "<<MMPR2(q.dump(),max))
if (max<m_min_max)  break;
int rc=0;
Ss ss; ss<<si.dump()<<MMPR(m_funcs.peer(sock));
m_dumper.annotate(ss.str());
char * buffer= new char[max];
//MM_ERR(MMPR4(max,sizeof(buffer),max,rct))
try {  
if (si.encoded())
rc  = SSL_read(si.m_ssl, buffer, max);
  else      rc = recv(sock, buffer, max, 0);
if (rc>0){ rct+=rc;  q.write(buffer,rc,0);
pnio->new_data(q,rc);
m_dumper.print(buffer,rc); 
//m_saver.out(si.sock_session(), sim.sock_session(), buffer, rc);
m_saver.out(xfer, buffer, rc);
} 

} catch (... ) { MM_ERR(" read threw "); }
delete[] buffer;
          if (rc < 0)
          {
            if (errno != EWOULDBLOCK)
            {
             MM_ERR(MMPR3(si.dump(),sock,m_funcs.eText())) ; //  perror("  recv() failed");
si.set_doa();     
pnio->set_doa(); 
//if (!si.nio()) {        
//SockInfo& sim=m_sd.get(si.mate()); // m_socks[si.mate()];
//sim.set_doa();   }           

   //           close_conn = TRUE;
            }
            break;
          }

          /*****************************************************/
          /* Check to see if the connection has been           */
          /* closed by the client                              */
          /*****************************************************/
          if (rc == 0)
          {
            printf("  Connection closed\n");
si.set_doa();      
pnio->set_doa();
//if (!si.nio()) {       
//SockInfo& sim=m_sd.get(si.mate()); // m_socks[si.mate()];
//sim.set_doa();   }           
//            close_conn = TRUE;
            break;
          }

} //  while (false) ;
if (rct>0) { if (m_dumper.stuff()) { MM_ERR(m_dumper.output(1))} }
//MM_ERR(" fick sht ") 


return 0; 
} // InputsNio
// FIXME compiler complained unusedref 
//SockInfo& sim=m_sd.get(si.mate()); // m_socks[sock];
IdxTy InputsMate(const IdxTy sock, SockInfo & si)
{

IdxTy rct=0;
StrTy xfer=m_funcs.peer(sock)+"..."+m_funcs.peer(si.mate());

//MM_ERR(" input  conn ")
while ( true)
//do 
{
auto & q=si.m_que;
IdxTy max=q.space();
//MM_ERR(" fick "<<MMPR2(q.dump(),max))
if (max<m_min_max)  break;
int rc=0;
Ss ss; ss<<si.dump()<<MMPR(m_funcs.peer(sock));
m_dumper.annotate(ss.str());
char * buffer= new char[max];
//MM_ERR(MMPR4(max,sizeof(buffer),max,rct))
try {  
if (si.encoded())
rc  = SSL_read(si.m_ssl, buffer, max);
  else      rc = recv(sock, buffer, max, 0);
if (rc>0){ rct+=rc;  q.write(buffer,rc,0);
m_dumper.print(buffer,rc); 
//m_saver.out(si.sock_session(), sim.sock_session(), buffer, rc);
m_saver.out(xfer, buffer, rc);
} 

} catch (... ) { MM_ERR(" read threw "); }
delete[] buffer;
          if (rc < 0)
          {
            if (errno != EWOULDBLOCK)
            {
             MM_ERR(MMPR3(si.dump(),sock,m_funcs.eText())) ; //  perror("  recv() failed");
si.set_doa();     
if (!si.nio()) {        
SockInfo& sim=m_sd.get(si.mate()); // m_socks[si.mate()];
sim.set_doa();   }           

   //           close_conn = TRUE;
            }
            break;
          }

          /*****************************************************/
          /* Check to see if the connection has been           */
          /* closed by the client                              */
          /*****************************************************/
          if (rc == 0)
          {
            printf("  Connection closed\n");
si.set_doa();      
if (!si.nio()) {       
SockInfo& sim=m_sd.get(si.mate()); // m_socks[si.mate()];
sim.set_doa();   }           
//            close_conn = TRUE;
            break;
          }

} //  while (false) ;
if (rct>0) { if (m_dumper.stuff()) { MM_ERR(m_dumper.output(1))} }
//MM_ERR(" fick sht ") 

return 0;
} // InputsMate

IdxTy Outputs(const int sock)
{
//SockInfo& si=m_socks[sock];
SockInfo& si=m_sd.get(sock); // m_socks[sock];
bool is_nio=si.nio();
//if (m_flow_msg) {MM_ERR(MMPR2(sock,is_nio))   } 
if (is_nio) return OutputsNio(sock,si);
return OutputsMate(sock,si);

} // Outputs 
IdxTy OutputsNio(const int sock, SockInfo & si)
{
NettleIO * pnio=si.pnio();
auto & q=pnio->que();
int rct=0; 
while ( true)
{
// bytes send or an error 
int rc=0;
IdxTy len=0;
do { 
const char * buffer=0;
// causes superfluous zero take on first iter 
q.take(rc);
q.contig(buffer,len);
if (len==0) { if (rct&&m_flow_msg) MM_ERR(MMPR(rct)) return 0; }
//if (m_flow_msg) MM_ERR(MMPR2(buffer,len))
if (m_flow_msg) MM_ERR(MMPR(len))
if (!si.encoded())
rc = send(sock, buffer, len, 0);
else rc=SSL_write(si.m_ssl, buffer, len);
if (rc>0) rct+=rc;
} while (rc>0);
if (m_flow_msg) MM_ERR(" done with outloop "<<MMPR2(len,rc))
  if (rc < 0)
   {
      if (errno != EWOULDBLOCK)
      {
        MM_ERR(MMPR3(si.dump(),pnio->dump(),m_funcs.eText())) ; 
		si.set_doa();            pnio->set_doa();            
      }
else
      {
            if (m_flow_msg)  
				MM_ERR("woudl block "<< MMPR3(si.dump(),pnio->dump(),m_funcs.eText())) ; // 
          }
break;
	} // rc<0
          if (len) if (rc == 0)
          {
			if(m_flow_msg) { MM_ERR(" closed sock "<<MMPR2(len,rc));
             MM_ERR("final state  "<< MMPR3(si.dump(),pnio->dump(),m_funcs.eText())) ; } // 
si.set_doa();            pnio->set_doa();            
            break;
          }
}
if (m_flow_msg) MM_ERR(MMPR(rct))

return 0; 
} // OutputsNio

IdxTy OutputsMate(const int sock, SockInfo & si)
{
//SockInfo& sim=m_socks[si.mate()];
const bool src=m_sd.has(si.mate());
if (!src) { si.set_doa(); return 0; } 
SockInfo& sim=m_sd.get(si.mate());
auto & q=sim.m_que;
//MM_ERR(" outputs "<<MMPR(sock)) 
int rct=9; 
while ( true)
{
// bytes send or an error 
int rc=0;
IdxTy len=0;
do { 
const char * buffer=0;
// causes superfluous zero take on first iter 
q.take(rc);
q.contig(buffer,len);
if (len==0) { if (rct&&m_flow_msg) MM_ERR(MMPR(rct)) return 0; }
// non ascii fick 
//if (m_flow_msg) MM_ERR(MMPR2(buffer,len))
if (m_flow_msg) MM_ERR(MMPR(len))
if (!si.encoded())
rc = send(sock, buffer, len, 0);
else rc=SSL_write(si.m_ssl, buffer, len);
if (rc>0) rct+=rc;
} while (rc>0);
if (m_flow_msg) MM_ERR(" done with outloop "<<MMPR2(len,rc))
  if (rc < 0)
   {
      if (errno != EWOULDBLOCK)
      {
        MM_ERR(MMPR3(si.dump(),sim.dump(),m_funcs.eText())) ; 
		si.set_doa();            sim.set_doa();            
      }
else
      {
            if (m_flow_msg)  
				MM_ERR("woudl block "<< MMPR3(si.dump(),sim.dump(),m_funcs.eText())) ; // 
          }
break;
	} // rc<0
          if (len) if (rc == 0)
          {
			if(m_flow_msg) { MM_ERR(" closed sock "<<MMPR2(len,rc));
             MM_ERR("final state  "<< MMPR3(si.dump(),sim.dump(),m_funcs.eText())) ; } // 
si.set_doa();            sim.set_doa();            
            break;
          }
}
if (m_flow_msg) MM_ERR(MMPR(rct))
return 0;

} // OutputsMate



bool SetupOutbound(const StrTy & n, const Pipe & p, const IdxTy sflags )
{
// setup mating outbound connection
SockInfo si;
p.setup(si);
// this uses si.out_xxx for conn and sets si to output... 
int sock=m_funcs.connect(si);
//si.output(sock);
// m_socks[sock]=si;
si.sock(sock); m_sd.set(si); 
IdxTy pos=m_fds.add_output(sock);
if (false) { MM_ERR(MMPR2(pos,sock))}
return (sock>0)?false:true;
} // SetupOutbound

bool SetupServer(const StrTy & n, const Pipe & p, const IdxTy sflags )
{
if (p.inbound_nio())
{
return SetupOutbound(n,p,sflags);
} // inbound_nio
int sock=m_funcs.server_socket4(p.ip_in,p.port_in,sflags);
if (sock<0)
{
MM_ERR(" bad sok for pipe "<<MMPR3(n,p.dump(), m_funcs.eText()))
return true ; // continue;
} // bad sock 
// create sock info and fds
// don't use pos let fds manage... 
IdxTy pos=m_fds.add_listen(sock);
if ( false)  { MM_ERR(MMPR2(sock,pos)) } 
SockInfo si;
p.setup(si);
si.listening(sock);
// m_socks[sock]=si;
si.sock(sock); m_sd.set(si); 

return false; 

} // SetupServer



////////////////////////////////////////////////////////////////
void SetupServers()
{
const IdxTy sflags=0;
// create all the listen sockets setup the fid table 
MM_LOOP(ii,m_pipes)
{
const StrTy& n=(*ii).first;
const auto & p=(*ii).second;
SetupServer(n,p,sflags);
} // ii 
} // SetupServers;
// was going to let fds do this but do it here I guess 
void FixFdss()
{
m_sd.clean(m_fds, m_norm_err?1:0);
//MM_ERR("fix")


} // FixFdss

void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Add(Pipe & p, const StrTy & sin, const IdxTy flags)
{
// allow over-writing of user names but not auto gen names 
StrTy name="";
BaseParams kvp(sin);
kvp.get(name,"name");
if (name=="") { Ss ss; ss<<"ADD"<<m_pipes.size();
StrTy name=ss.str();
while (m_pipes.find(name)!=m_pipes.end()) { name=name+"+"; } 
}
//m_pipes[m_pipes.size()]=p;
m_pipes[name]=p;

} // Add

// there is no ctor with this is need not call init()
void Init(const StrTy & sin, Creds & cred, const IdxTy flags)
{
//BaseParams kvp(sin);
Pipe p(sin,&cred,flags);
Add(p,sin,flags);
} // Init

void Init()
{
m_done=false;
m_flow_msg=!true; 
m_norm_err=!true; 
m_size=0;
m_mu_sleep=10000;
m_thread.tgt(this);
// threading can almost be eliminated except that the polling
// thread may compete with the app ui thread. 
m_mutex_vector= MutexVector(2);
m_min_max=128;
} // Init

StrTy Stats(const StrTy & sin,const IdxTy flags) {
Ss ss;
BaseParams kvp(sin);
StrTy cmd="socks";
kvp.get(cmd,"cmd");
MM_ERR(MMPR(cmd))
if (cmd=="socks") ss<<SocksStats();
if (cmd=="dump") ss<<Dump();
if (cmd=="dump-on") m_dumper.active(true);
if (cmd=="dump-off") m_dumper.active(!true);
return ss.str(); 
} // Stats
StrTy SocksStats()
{
Ss ss;
EnterSerial(0);
//MM_LOOP(ii,m_socks)
MM_LOOP(ii,m_sd.map())
{
const int s=(*ii).first;
const auto & si=(*ii).second;
ss<<MMPR2(s,si.dump())<<CRLF;
} // ii 
ExitSerial(0);
return ss.str();
} // SocksStats



// MEMBERS
IdxTy m_size;
FdsArray m_fds;
//SockMap m_socks;
SockDrawer m_sd;
PollingThread m_thread;
PipeMap m_pipes;
IdxTy m_mu_sleep;
bool m_done;
Funcs m_funcs;
YaHex m_dumper;
IdxTy m_min_max;
bool m_flow_msg,m_norm_err;
Saver m_saver;
}; // mjm_nettle_pollock

//////////////////////////////////////////////

template <class Tr>
class mjm_nettle_pollock_map : public std::map<typename Tr::StrTy, mjm_nettle_pollock< Tr > >  
{
 typedef mjm_nettle_pollock_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_nettle_pollock< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_nettle_pollock_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_nettle_pollock_map




////////////////////////////////////////////
#ifdef  TEST_MJM_NETTLE_POLLOCK
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_nettle_pollock <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;

#define CI(n) atoi(cip.wif(n).c_str()) 

void about()
{
Ss ss;
ss<<" MJM_NETTLE_POLLOCK "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;

#define CIP(n) atoi(cip.wif(n).c_str())
#define CFP(n) atof(cip.wif(n).c_str())

int main(int argc,char **args)
{
about();
typedef mjm_nettle_pollock<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="test") {StrTy xxx=x.xxx_test(cip.p1,CIP(2)); MM_ERR(MMPR(xxx))  }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_NETTLE_POLLOCK_H__ 
