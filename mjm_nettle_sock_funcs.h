#ifndef MJM_NETTLE_SOCK_FUNCS_H__
#define MJM_NETTLE_SOCK_FUNCS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"

#include "mjm_ya_errno.h"
#include "mjm_nettle_sock_info.h"
#include "mjm_nettle_creds.h"
#include "mjm_nettle_que.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

// https://www.ibm.com/docs/en/i/7.4?topic=designs-using-poll-instead-select

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <errno.h>
// from ai example 
    #include <openssl/ssl.h>
    #include <openssl/err.h>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h>

    #include <cstring>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <cerrno>
 

/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2025 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Talking Rock GA 30175 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_nettle_sock_funcs.h},
  url = {},
  version = {0.0.0},
  date-started={2025-04-06},
}
*/

// Sun 06 Apr 2025 04:44:42 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_nettle_sock_funcs   
// QUICKCOMPILE  g++  -MMD -MF mjm_nettle_sock_funcs.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_NETTLE_SOCK_FUNCS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_nettle_sock_funcs.h  -o mjm_nettle_sock_funcs.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_nettle_sock_funcs("mjm_nettle_sock_funcs" , "  ");

template <class Tr>
class mjm_nettle_sock_funcs 
{
 typedef mjm_nettle_sock_funcs Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_ya_errno<Tr> ErrNo;

typedef mjm_nettle_creds<Tr> Creds;
typedef mjm_nettle_que<Tr> Que;
typedef mjm_nettle_sock_info<Tr> SockInfo;

// API

public:
mjm_nettle_sock_funcs() {Init(); }
mjm_nettle_sock_funcs(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_nettle_sock_funcs(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
StrTy eText(const int e)const { return m_err.lerrno(e); } 
StrTy eText()const  { return m_err.lerrno(errno); } 
void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

int server_socket4(const StrTy & ip, const int port, const IdxTy flags)
{ return  ServerSocket4( ip,  port,  flags);  }

int client_socket4(const StrTy & ip, const int port, const IdxTy flags) const
{ return  ClientSocket4( ip,  port,  flags);  }

int non_block(int sock) const
{

    // Set socket to non-blocking mode
    int xflags = fcntl(sock, F_GETFL, 0);
    if (xflags == -1) {
        perror("fcntl get failed");
        return 1;
    }

    if (fcntl(sock, F_SETFL, xflags | O_NONBLOCK) == -1) {
        perror("fcntl set failed");
        return 1;
    }


return 0; 


} // non_block



int accept(const int sock, SockInfo & si) const 
{ 
int newsock= ::accept(sock, NULL, NULL); 
MM_ERR(MMPR3(__FUNCTION__,sock,newsock))
if (newsock<0) { return 0; } 

non_block(newsock);
///// move this ficking sht into funcs it appears twice 

si.input(newsock);
if (si.enc_in&1)
{
init_ssl();
open_ssl_context(si,*(si.m_creds));

} // input encrypted 

return newsock;
} 

int connect( SockInfo & si) const 
{ 
int newsock= client_socket4(si.ip_out,si.port_out,0); 
MM_ERR(MMPR3(__FUNCTION__,si.sock(),newsock)<<MMPR2(si.ip_out,si.port_out))
if (newsock<0) { return newsock ; } 
si.output(newsock);
if (si.enc_out&1)
{
init_ssl();
open_ssl_client_context(si,*(si.m_creds));

} // input encrypted 

return newsock;
} 
//  fck use goog ai a fick 
StrTy peer(const int sock ) const
{
Ss ss;

    sockaddr_in peer_addr;
    socklen_t peer_addr_len = sizeof(peer_addr);
    if (getpeername(sock, (struct sockaddr*)&peer_addr, &peer_addr_len) == -1) {
   //     std::cerr << "Error getting peer name" << std::endl;
ss<<" no peer error"<< MMPR(eText());
    //    close(sockfd);
        return  ss.str();
    }

    char ip_str[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &peer_addr.sin_addr, ip_str, INET_ADDRSTRLEN);
    int port = ntohs(peer_addr.sin_port);

   // std::cout << "Connected to peer: " << ip_str << ":" << port << std::endl;
ss<<ip_str<<"."<<port;

return ss.str();
} // peer

// goog ai generated

StrTy local(const int sock ) const
{
Ss ss;

   // Get the local address and port
    sockaddr_in retrieved_local_addr;
    socklen_t addr_len = sizeof(retrieved_local_addr);
    if (getsockname(sock, (struct sockaddr*)&retrieved_local_addr, &addr_len) == -1) {
        ss<< "Error getting socket name" << MMPR(eText());
}

    // Convert the IP address to a string
    char ip_str[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &retrieved_local_addr.sin_addr, ip_str, INET_ADDRSTRLEN);

    // Print the local IP address and port
//    std::cout << "Local IP address: " << ip_str << std::endl;
//    std::cout << "Local port: " << ntohs(retrieved_local_addr.sin_port) << std::endl;
ss<<ip_str<<"."<<ntohs(retrieved_local_addr.sin_port); // 
return ss.str();
} // peer



// probably just once per app
IdxTy init_ssl( const IdxTy flags=0) const
{
if (m_ssl_inited) return 0; 
MM_ERR(" ssl  init ")
    SSL_library_init();
    OpenSSL_add_all_algorithms();
    SSL_load_error_strings();
m_ssl_inited=true;
MM_ERR(" ssl  inited ")
return 0; 
} // init_ssl 
IdxTy open_ssl_context(SockInfo & si, const Creds & creds) const
{
// make sure its encrypted lol. 
MM_ERR(" begin ssl open ")
    si.m_meth = TLS_server_method(); // Or TLS_client_method() for client
     si.m_ctx = SSL_CTX_new(si.m_meth);
    if (!si.m_ctx) {
MM_ERR(" no context "<<MMPR(eText()))
}
// int SSL_use_certificate(SSL *ssl, X509 *x);
if (SSL_CTX_use_certificate_file(si.m_ctx, creds.certfile().c_str(), SSL_FILETYPE_PEM) <= 0)
{
MM_ERR(" bad cert"<<MMPR2(creds.certfile(),eText()))
} // cert
// int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);

    if (SSL_CTX_use_PrivateKey_file(si.m_ctx, creds.keyfile().c_str(), SSL_FILETYPE_PEM) <= 0)
{
MM_ERR(" bad key"<<MMPR2(creds.keyfile(),eText()))
 } // key 

 si.m_ssl = SSL_new(si.m_ctx);
    SSL_set_fd(si.m_ssl, si.sock()); // Or sock for client
// Perform Handshake: Perform the TLS/SSL handshake. 
    if (SSL_accept(si.m_ssl) <= 0) {
if (errno!=EWOULDBLOCK) MM_ERR(" hand shake fails "<<MMPR2(si.dump(), eText()))
else {MM_ERR(" handshake started") }
} // Server
else MM_ERR(" handshacke seems to go ok ")




return 0;
} // open_ssl_context 

IdxTy open_ssl_client_context(SockInfo & si, const Creds & creds) const
{
// make sure its encrypted lol. 
MM_ERR(" begin ssl open ")
    si.m_meth = TLS_server_method(); // Or TLS_client_method() for client
     si.m_ctx = SSL_CTX_new(si.m_meth);
    if (!si.m_ctx) {
MM_ERR(" no context "<<MMPR(eText()))
}
// int SSL_use_certificate(SSL *ssl, X509 *x);
if (SSL_CTX_use_certificate_file(si.m_ctx, creds.certfile().c_str(), SSL_FILETYPE_PEM) <= 0)
{
MM_ERR(" bad cert"<<MMPR2(creds.certfile(),eText()))
} // cert
// int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);

    if (SSL_CTX_use_PrivateKey_file(si.m_ctx, creds.keyfile().c_str(), SSL_FILETYPE_PEM) <= 0)
{
MM_ERR(" bad key"<<MMPR2(creds.keyfile(),eText()))
 } // key 

 si.m_ssl = SSL_new(si.m_ctx);
    SSL_set_fd(si.m_ssl, si.sock()); // Or sock for client
// Perform Handshake: Perform the TLS/SSL handshake. 
    //if (SSL_accept(si.m_ssl) <= 0) {
    if (SSL_connect(si.m_ssl) <= 0) {
MM_ERR(" hand shake fails "<<MMPR2(si.dump(), eText()))
} // Server
else MM_ERR("client  handshacke seems to go ok ")

return 0;
} // CreateTLS

IdxTy Send(SockInfo &si)
{
    // Send data
    std::string message = "Hello, TLS!";
    int bytes_written = SSL_write(si.m_ssl, message.c_str(), message.length());
    if (bytes_written <= 0) {
     MM_ERR(" wtf ")  //      ERR_print_errors_fp(stderr);
return 0; 
}



return 0;
} // open_ssl_client_context 





StrTy xxx_test(const StrTy & sin, const IdxTy flags) 
{ return XXX_test(sin,flags); } 
~mjm_nettle_sock_funcs() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=((~1)<<b); }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
StrTy XXX_test(const StrTy & sin, const IdxTy flags) 
{
StrTy sout="";
MM_ERR(MMPR3(sin,flags,sout))
BaseParams kvp(sin);

return sout;
} // XXX_test
// https://developer.ibm.com/tutorials/l-sock/
int ClientSocket4(const StrTy & ip, const int port, const IdxTy flags) const
{
            int sock;
            struct sockaddr_in echoserver;
            /* Create the TCP socket */
            if ((sock = socket(AF_INET, SOCK_STREAM|SOCK_NONBLOCK, IPPROTO_TCP)) < 0) {
            //  Die("Failed to create socket");
            
MM_ERR(MMPR4(__FUNCTION__,ip,port,eText()))
return 01;
}
/* Construct the server sockaddr_in structure */
            memset(&echoserver, 0, sizeof(echoserver));       /* Clear struct */
            echoserver.sin_family = AF_INET;                  /* Internet/IP */
            echoserver.sin_addr.s_addr = inet_addr(ip.c_str());  /* IP address */
            echoserver.sin_port = htons(port);       /* server port */
            /* Establish connection */
            if (::connect(sock,
                        (struct sockaddr *) &echoserver,
                        sizeof(echoserver)) < 0) {
if (errno!=EINPROGRESS)            
{MM_ERR(" connect failed "<<MMPR2(sock,eText())) }
else { MM_ERR(" connect started ") }
return sock ;
}
return sock;
} // ClientSocket4
int ServerSocket4(const StrTy & ip, const int port, const IdxTy flags)
{
//Create Socket: Create a standard TCP socket using the socket() function. 

    //int sock = socket(AF_INET, SOCK_STREAM, 0);
    int sock = socket(AF_INET, SOCK_STREAM| SOCK_NONBLOCK, 0);
    if (sock < 0) { MM_ERR(" bad sock "<<eText()) return sock; }


non_block(sock);
/*
    // Set socket to non-blocking mode
    int xflags = fcntl(sock, F_GETFL, 0);
    if (xflags == -1) {
        perror("fcntl get failed");
        return 1;
    }

    if (fcntl(sock, F_SETFL, xflags | O_NONBLOCK) == -1) {
        perror("fcntl set failed");
        return 1;
    }


*/




//Bind and Listen (Server): For a server, bind the socket to an address and port, then listen for connections. 

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
//    server_addr.sin_addr.s_addr =inet_pton("127.0.0.1"); //  INADDR_ANY;

if (inet_pton(AF_INET, ip.c_str(), &server_addr.sin_addr) <= 0) {
MM_ERR(" bad addr"<<MMPR4(ip,port,eText(),sock)); return BAD; }

    server_addr.sin_port = htons(port);
  int rcbind=  bind(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
if (rcbind<0) { MM_ERR(" bad bind "<<MMPR4(ip,port,sock,eText())<<MMPR(rcbind)) return BAD; } 
    listen(sock, m_conn_que);
return sock;
} 






void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Init()
{
m_conn_que=15;
m_ssl_inited=false;
} // Init



// MEMBERS
IdxTy m_conn_que;
ErrNo m_err;
mutable bool m_ssl_inited;
}; // mjm_nettle_sock_funcs

//////////////////////////////////////////////

template <class Tr>
class mjm_nettle_sock_funcs_map : public std::map<typename Tr::StrTy, mjm_nettle_sock_funcs< Tr > >  
{
 typedef mjm_nettle_sock_funcs_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_nettle_sock_funcs< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_nettle_sock_funcs_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_nettle_sock_funcs_map




////////////////////////////////////////////
#ifdef  TEST_MJM_NETTLE_SOCK_FUNCS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_nettle_sock_funcs <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;

#define CI(n) atoi(cip.wif(n).c_str()) 

void about()
{
Ss ss;
ss<<" MJM_NETTLE_SOCK_FUNCS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;

#define CIP(n) atoi(cip.wif(n).c_str())
#define CFP(n) atof(cip.wif(n).c_str())

int main(int argc,char **args)
{
about();
typedef mjm_nettle_sock_funcs<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="test") {StrTy xxx=x.xxx_test(cip.p1,CIP(2)); MM_ERR(MMPR(xxx))  }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_NETTLE_SOCK_FUNCS_H__ 
