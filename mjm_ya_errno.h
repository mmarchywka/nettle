#ifndef MJM_YA_ERRNO_H__
#define MJM_YA_ERRNO_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <errno.h> 
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2025 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Talking Rock GA 30175 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_ya_errno.h},
  url = {},
  version = {0.0.0},
  date-started={2025-04-06},
}
*/

// Sun 06 Apr 2025 06:38:45 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_ya_errno   
// QUICKCOMPILE  g++  -MMD -MF mjm_ya_errno.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_YA_ERRNO -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_ya_errno.h  -o mjm_ya_errno.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_ya_errno("mjm_ya_errno" , "https://kdave.github.io/errno.h/");

template <class Tr>
class mjm_ya_errno 
{
 typedef mjm_ya_errno Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef std::map<int,StrTy> Map;

// API

public:
mjm_ya_errno() {Init(); }
mjm_ya_errno(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_ya_errno(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}

void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }
StrTy lerrno(const int e)const  { const auto ii= m_map.find(e);if (ii!=m_map.end()) return (*ii).second; Ss ss; ss<<" nothing for "<<MMPR(3);  return ss.str();  } 
StrTy xxx_test(const StrTy & sin, const IdxTy flags) 
{ return XXX_test(sin,flags); } 
~mjm_ya_errno() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=((~1)<<b); }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
StrTy XXX_test(const StrTy & sin, const IdxTy flags) 
{
StrTy sout="";
MM_ERR(MMPR3(sin,flags,sout))
BaseParams kvp(sin);

return sout;
} // XXX_test
// https://kdave.github.io/errno.h/
void MakeMap()
{
#if 0
m_map[EPERM]=" 1 0x01 0x..ffff Operation not permitted";
m_map[ENOENT]=" 2 0x02 0x..fffe No such file or directory";
m_map[ESRCH]=" 3 0x03 0x..fffd No such process";
m_map[EINTR]=" 4 0x04 0x..fffc Interrupted system call";
m_map[EIO]=" 5 0x05 0x..fffb I/O error";
m_map[ENXIO]=" 6 0x06 0x..fffa No such device or address";
m_map[E2BIG]=" 7 0x07 0x..fff9 Argument list too long";
m_map[ENOEXEC]=" 8 0x08 0x..fff8 Exec format error";
m_map[EBADF]=" 9 0x09 0x..fff7 Bad file number";
m_map[ECHILD]=" 10 0x0a 0x..fff6 No child processes";
m_map[EAGAIN]=" 11 0x0b 0x..fff5 Try again";
m_map[ENOMEM]=" 12 0x0c 0x..fff4 Out of memory";
m_map[EACCES]=" 13 0x0d 0x..fff3 Permission denied";
m_map[EFAULT]=" 14 0x0e 0x..fff2 Bad address";
m_map[ENOTBLK]=" 15 0x0f 0x..fff1 Block device required";
m_map[EBUSY]=" 16 0x10 0x..fff0 Device or resource busy";
m_map[EEXIST]=" 17 0x11 0x..ffef File exists";
m_map[EXDEV]=" 18 0x12 0x..ffee Cross-device link";
m_map[ENODEV]=" 19 0x13 0x..ffed No such device";
m_map[ENOTDIR]=" 20 0x14 0x..ffec Not a directory";
m_map[EISDIR]=" 21 0x15 0x..ffeb Is a directory";
m_map[EINVAL]=" 22 0x16 0x..ffea Invalid argument";
m_map[ENFILE]=" 23 0x17 0x..ffe9 File table overflow";
m_map[EMFILE]=" 24 0x18 0x..ffe8 Too many open files";
m_map[ENOTTY]=" 25 0x19 0x..ffe7 Not a typewriter";
m_map[ETXTBSY]=" 26 0x1a 0x..ffe6 Text file busy";
m_map[EFBIG]=" 27 0x1b 0x..ffe5 File too large";
m_map[ENOSPC]=" 28 0x1c 0x..ffe4 No space left on device";
m_map[ESPIPE]=" 29 0x1d 0x..ffe3 Illegal seek";
m_map[EROFS]=" 30 0x1e 0x..ffe2 Read-only file system";
m_map[EMLINK]=" 31 0x1f 0x..ffe1 Too many links";
m_map[EPIPE]=" 32 0x20 0x..ffe0 Broken pipe";
m_map[EDOM]=" 33 0x21 0x..ffdf Math argument out of domain of func";
m_map[ERANGE]=" 34 0x22 0x..ffde Math result not representable";
m_map[EDEADLK]=" 35 0x23 0x..ffdd Resource deadlock would occur";
m_map[ENAMETOOLONG]=" 36 0x24 0x..ffdc File name too long";
m_map[ENOLCK]=" 37 0x25 0x..ffdb No record locks available";
m_map[ENOSYS]=" 38 0x26 0x..ffda Function not implemented";
m_map[ENOTEMPTY]=" 39 0x27 0x..ffd9 Directory not empty";
m_map[ELOOP]=" 40 0x28 0x..ffd8 Too many symbolic links encountered";
m_map[EWOULDBLOCK]=" EAGAIN";
m_map[ENOMSG]=" 42 0x2a 0x..ffd6 No message of desired type";
m_map[EIDRM]=" 43 0x2b 0x..ffd5 Identifier removed";
m_map[ECHRNG]=" 44 0x2c 0x..ffd4 Channel number out of range";
m_map[EL2NSYNC]=" 45 0x2d 0x..ffd3 Level 2 not synchronized";
m_map[EL3HLT]=" 46 0x2e 0x..ffd2 Level 3 halted";
m_map[EL3RST]=" 47 0x2f 0x..ffd1 Level 3 reset";
m_map[ELNRNG]=" 48 0x30 0x..ffd0 Link number out of range";
m_map[EUNATCH]=" 49 0x31 0x..ffcf Protocol driver not attached";
m_map[ENOCSI]=" 50 0x32 0x..ffce No CSI structure available";
m_map[EL2HLT]=" 51 0x33 0x..ffcd Level 2 halted";
m_map[EBADE]=" 52 0x34 0x..ffcc Invalid exchange";
m_map[EBADR]=" 53 0x35 0x..ffcb Invalid request descriptor";
m_map[EXFULL]=" 54 0x36 0x..ffca Exchange full";
m_map[ENOANO]=" 55 0x37 0x..ffc9 No anode";
m_map[EBADRQC]=" 56 0x38 0x..ffc8 Invalid request code";
m_map[EBADSLT]=" 57 0x39 0x..ffc7 Invalid slot";
m_map[EDEADLOCK]=" EDEADLK";
m_map[EBFONT]=" 59 0x3b 0x..ffc5 Bad font file format";
m_map[ENOSTR]=" 60 0x3c 0x..ffc4 Device not a stream";
m_map[ENODATA]=" 61 0x3d 0x..ffc3 No data available";
m_map[ETIME]=" 62 0x3e 0x..ffc2 Timer expired";
m_map[ENOSR]=" 63 0x3f 0x..ffc1 Out of streams resources";
m_map[ENONET]=" 64 0x40 0x..ffc0 Machine is not on the network";
m_map[ENOPKG]=" 65 0x41 0x..ffbf Package not installed";
m_map[EREMOTE]=" 66 0x42 0x..ffbe Object is remote";
m_map[ENOLINK]=" 67 0x43 0x..ffbd Link has been severed";
m_map[EADV]=" 68 0x44 0x..ffbc Advertise error";
m_map[ESRMNT]=" 69 0x45 0x..ffbb Srmount error";
m_map[ECOMM]=" 70 0x46 0x..ffba Communication error on send";
m_map[EPROTO]=" 71 0x47 0x..ffb9 Protocol error";
m_map[EMULTIHOP]=" 72 0x48 0x..ffb8 Multihop attempted";
m_map[EDOTDOT]=" 73 0x49 0x..ffb7 RFS specific error";
m_map[EBADMSG]=" 74 0x4a 0x..ffb6 Not a data message";
m_map[EOVERFLOW]=" 75 0x4b 0x..ffb5 Value too large for defined data type";
m_map[ENOTUNIQ]=" 76 0x4c 0x..ffb4 Name not unique on network";
m_map[EBADFD]=" 77 0x4d 0x..ffb3 File descriptor in bad state";
m_map[EREMCHG]=" 78 0x4e 0x..ffb2 Remote address changed";
m_map[ELIBACC]=" 79 0x4f 0x..ffb1 Can not access a needed shared library";
m_map[ELIBBAD]=" 80 0x50 0x..ffb0 Accessing a corrupted shared library";
m_map[ELIBSCN]=" 81 0x51 0x..ffaf .lib section in a.out corrupted";
m_map[ELIBMAX]=" 82 0x52 0x..ffae Attempting to link in too many shared libraries";
m_map[ELIBEXEC]=" 83 0x53 0x..ffad Cannot exec a shared library directly";
m_map[EILSEQ]=" 84 0x54 0x..ffac Illegal byte sequence";
m_map[ERESTART]=" 85 0x55 0x..ffab Interrupted system call should be restarted";
m_map[ESTRPIPE]=" 86 0x56 0x..ffaa Streams pipe error";
m_map[EUSERS]=" 87 0x57 0x..ffa9 Too many users";
m_map[ENOTSOCK]=" 88 0x58 0x..ffa8 Socket operation on non-socket";
m_map[EDESTADDRREQ]=" 89 0x59 0x..ffa7 Destination address required";
m_map[EMSGSIZE]=" 90 0x5a 0x..ffa6 Message too long";
m_map[EPROTOTYPE]=" 91 0x5b 0x..ffa5 Protocol wrong type for socket";
m_map[ENOPROTOOPT]=" 92 0x5c 0x..ffa4 Protocol not available";
m_map[EPROTONOSUPPORT]=" 93 0x5d 0x..ffa3 Protocol not supported";
m_map[ESOCKTNOSUPPORT]=" 94 0x5e 0x..ffa2 Socket type not supported";
m_map[EOPNOTSUPP]=" 95 0x5f 0x..ffa1 Operation not supported on transport endpoint";
m_map[EPFNOSUPPORT]=" 96 0x60 0x..ffa0 Protocol family not supported";
m_map[EAFNOSUPPORT]=" 97 0x61 0x..ff9f Address family not supported by protocol";
m_map[EADDRINUSE]=" 98 0x62 0x..ff9e Address already in use";
m_map[EADDRNOTAVAIL]=" 99 0x63 0x..ff9d Cannot assign requested address";
m_map[ENETDOWN]=" 100 0x64 0x..ff9c Network is down";
m_map[ENETUNREACH]=" 101 0x65 0x..ff9b Network is unreachable";
m_map[ENETRESET]=" 102 0x66 0x..ff9a Network dropped connection because of reset";
m_map[ECONNABORTED]=" 103 0x67 0x..ff99 Software caused connection abort";
m_map[ECONNRESET]=" 104 0x68 0x..ff98 Connection reset by peer";
m_map[ENOBUFS]=" 105 0x69 0x..ff97 No buffer space available";
m_map[EISCONN]=" 106 0x6a 0x..ff96 Transport endpoint is already connected";
m_map[ENOTCONN]=" 107 0x6b 0x..ff95 Transport endpoint is not connected";
m_map[ESHUTDOWN]=" 108 0x6c 0x..ff94 Cannot send after transport endpoint shutdown";
m_map[ETOOMANYREFS]=" 109 0x6d 0x..ff93 Too many references: cannot splice";
m_map[ETIMEDOUT]=" 110 0x6e 0x..ff92 Connection timed out";
m_map[ECONNREFUSED]=" 111 0x6f 0x..ff91 Connection refused";
m_map[EHOSTDOWN]=" 112 0x70 0x..ff90 Host is down";
m_map[EHOSTUNREACH]=" 113 0x71 0x..ff8f No route to host";
m_map[EALREADY]=" 114 0x72 0x..ff8e Operation already in progress";
m_map[EINPROGRESS]=" 115 0x73 0x..ff8d Operation now in progress";
m_map[ESTALE]=" 116 0x74 0x..ff8c Stale NFS file handle";
m_map[EUCLEAN]=" 117 0x75 0x..ff8b Structure needs cleaning";
m_map[ENOTNAM]=" 118 0x76 0x..ff8a Not a XENIX named type file";
m_map[ENAVAIL]=" 119 0x77 0x..ff89 No XENIX semaphores available";
m_map[EISNAM]=" 120 0x78 0x..ff88 Is a named type file";
m_map[EREMOTEIO]=" 121 0x79 0x..ff87 Remote I/O error";
m_map[EDQUOT]=" 122 0x7a 0x..ff86 Quota exceeded";
m_map[ENOMEDIUM]=" 123 0x7b 0x..ff85 No medium found";
m_map[EMEDIUMTYPE]=" 124 0x7c 0x..ff84 Wrong medium type";
m_map[ECANCELED]=" 125 0x7d 0x..ff83 Operation Canceled";
m_map[ENOKEY]=" 126 0x7e 0x..ff82 Required key not available";
m_map[EKEYEXPIRED]=" 127 0x7f 0x..ff81 Key has expired";
m_map[EKEYREVOKED]=" 128 0x80 0x..ff80 Key has been revoked";
m_map[EKEYREJECTED]=" 129 0x81 0x..ff7f Key was rejected by service";
m_map[EOWNERDEAD]=" 130 0x82 0x..ff7e Owner died";
m_map[ENOTRECOVERABLE]=" 131 0x83 0x..ff7d State not recoverable";
m_map[ERFKILL]=" 132 0x84 0x..ff7c Operation not possible due to RF-kill";
m_map[EHWPOISON]=" 133 0x85 0x..ff7b Memory page has hardware error";
m_map[ERESTARTSYS]=" 512 0x200 0x..ff200";
m_map[ERESTARTNOINTR]=" 513 0x201 0x..ff1ff";
m_map[ERESTARTNOHAND]=" 514 0x202 0x..ff1fe restart if no handler..";
m_map[ENOIOCTLCMD]=" 515 0x203 0x..ff1fd No ioctl command";
m_map[ERESTART_RESTARTBLOCK]=" 516 0x204 0x..ff1fc restart by calling sys_restart_syscall";
m_map[EBADHANDLE]=" 521 0x209 0x..ff1f7 Illegal NFS file handle";
m_map[ENOTSYNC]=" 522 0x20a 0x..ff1f6 Update synchronization mismatch";
m_map[EBADCOOKIE]=" 523 0x20b 0x..ff1f5 Cookie is stale";
m_map[ENOTSUPP]=" 524 0x20c 0x..ff1f4 Operation is not supported";
m_map[ETOOSMALL]=" 525 0x20d 0x..ff1f3 Buffer or request is too small";
m_map[ESERVERFAULT]=" 526 0x20e 0x..ff1f2 An untranslatable error occurred";
m_map[EBADTYPE]=" 527 0x20f 0x..ff1f1 Type not supported by server";
m_map[EJUKEBOX]=" 528 0x210 0x..ff1f0 Request initiated, but will not complete before timeout";
m_map[EIOCBQUEUED]=" 529 0x211 0x..ff1ef iocb queued, will get completion event";
m_map[EIOCBRETRY]=" 530 0x212 0x..ff1ee iocb queued, will trigger a retry";
#endif
m_map[1]="EPERM  0x01 0x..ffff Operation not permitted";
m_map[2]="ENOENT  0x02 0x..fffe No such file or directory";
m_map[3]="ESRCH  0x03 0x..fffd No such process";
m_map[4]="EINTR  0x04 0x..fffc Interrupted system call";
m_map[5]="EIO  0x05 0x..fffb I/O error";
m_map[6]="ENXIO  0x06 0x..fffa No such device or address";
m_map[7]="E2BIG  0x07 0x..fff9 Argument list too long";
m_map[8]="ENOEXEC  0x08 0x..fff8 Exec format error";
m_map[9]="EBADF  0x09 0x..fff7 Bad file number";
m_map[10]="ECHILD  0x0a 0x..fff6 No child processes";
m_map[11]="EAGAIN  0x0b 0x..fff5 Try again";
m_map[12]="ENOMEM  0x0c 0x..fff4 Out of memory";
m_map[13]="EACCES  0x0d 0x..fff3 Permission denied";
m_map[14]="EFAULT  0x0e 0x..fff2 Bad address";
m_map[15]="ENOTBLK  0x0f 0x..fff1 Block device required";
m_map[16]="EBUSY  0x10 0x..fff0 Device or resource busy";
m_map[17]="EEXIST  0x11 0x..ffef File exists";
m_map[18]="EXDEV  0x12 0x..ffee Cross-device link";
m_map[19]="ENODEV  0x13 0x..ffed No such device";
m_map[20]="ENOTDIR  0x14 0x..ffec Not a directory";
m_map[21]="EISDIR  0x15 0x..ffeb Is a directory";
m_map[22]="EINVAL  0x16 0x..ffea Invalid argument";
m_map[23]="ENFILE  0x17 0x..ffe9 File table overflow";
m_map[24]="EMFILE  0x18 0x..ffe8 Too many open files";
m_map[25]="ENOTTY  0x19 0x..ffe7 Not a typewriter";
m_map[26]="ETXTBSY  0x1a 0x..ffe6 Text file busy";
m_map[27]="EFBIG  0x1b 0x..ffe5 File too large";
m_map[28]="ENOSPC  0x1c 0x..ffe4 No space left on device";
m_map[29]="ESPIPE  0x1d 0x..ffe3 Illegal seek";
m_map[30]="EROFS  0x1e 0x..ffe2 Read-only file system";
m_map[31]="EMLINK  0x1f 0x..ffe1 Too many links";
m_map[32]="EPIPE  0x20 0x..ffe0 Broken pipe";
m_map[33]="EDOM  0x21 0x..ffdf Math argument out of domain of func";
m_map[34]="ERANGE  0x22 0x..ffde Math result not representable";
m_map[35]="EDEADLK  0x23 0x..ffdd Resource deadlock would occur";
m_map[36]="ENAMETOOLONG  0x24 0x..ffdc File name too long";
m_map[37]="ENOLCK  0x25 0x..ffdb No record locks available";
m_map[38]="ENOSYS  0x26 0x..ffda Function not implemented";
m_map[39]="ENOTEMPTY  0x27 0x..ffd9 Directory not empty";
m_map[40]="ELOOP  0x28 0x..ffd8 Too many symbolic links encountered";
m_map[EAGAIN]="EWOULDBLOCK ";
m_map[42]="ENOMSG  0x2a 0x..ffd6 No message of desired type";
m_map[43]="EIDRM  0x2b 0x..ffd5 Identifier removed";
m_map[44]="ECHRNG  0x2c 0x..ffd4 Channel number out of range";
m_map[45]="EL2NSYNC  0x2d 0x..ffd3 Level 2 not synchronized";
m_map[46]="EL3HLT  0x2e 0x..ffd2 Level 3 halted";
m_map[47]="EL3RST  0x2f 0x..ffd1 Level 3 reset";
m_map[48]="ELNRNG  0x30 0x..ffd0 Link number out of range";
m_map[49]="EUNATCH  0x31 0x..ffcf Protocol driver not attached";
m_map[50]="ENOCSI  0x32 0x..ffce No CSI structure available";
m_map[51]="EL2HLT  0x33 0x..ffcd Level 2 halted";
m_map[52]="EBADE  0x34 0x..ffcc Invalid exchange";
m_map[53]="EBADR  0x35 0x..ffcb Invalid request descriptor";
m_map[54]="EXFULL  0x36 0x..ffca Exchange full";
m_map[55]="ENOANO  0x37 0x..ffc9 No anode";
m_map[56]="EBADRQC  0x38 0x..ffc8 Invalid request code";
m_map[57]="EBADSLT  0x39 0x..ffc7 Invalid slot";
m_map[EDEADLK]="EDEADLOCK ";
m_map[59]="EBFONT  0x3b 0x..ffc5 Bad font file format";
m_map[60]="ENOSTR  0x3c 0x..ffc4 Device not a stream";
m_map[61]="ENODATA  0x3d 0x..ffc3 No data available";
m_map[62]="ETIME  0x3e 0x..ffc2 Timer expired";
m_map[63]="ENOSR  0x3f 0x..ffc1 Out of streams resources";
m_map[64]="ENONET  0x40 0x..ffc0 Machine is not on the network";
m_map[65]="ENOPKG  0x41 0x..ffbf Package not installed";
m_map[66]="EREMOTE  0x42 0x..ffbe Object is remote";
m_map[67]="ENOLINK  0x43 0x..ffbd Link has been severed";
m_map[68]="EADV  0x44 0x..ffbc Advertise error";
m_map[69]="ESRMNT  0x45 0x..ffbb Srmount error";
m_map[70]="ECOMM  0x46 0x..ffba Communication error on send";
m_map[71]="EPROTO  0x47 0x..ffb9 Protocol error";
m_map[72]="EMULTIHOP  0x48 0x..ffb8 Multihop attempted";
m_map[73]="EDOTDOT  0x49 0x..ffb7 RFS specific error";
m_map[74]="EBADMSG  0x4a 0x..ffb6 Not a data message";
m_map[75]="EOVERFLOW  0x4b 0x..ffb5 Value too large for defined data type";
m_map[76]="ENOTUNIQ  0x4c 0x..ffb4 Name not unique on network";
m_map[77]="EBADFD  0x4d 0x..ffb3 File descriptor in bad state";
m_map[78]="EREMCHG  0x4e 0x..ffb2 Remote address changed";
m_map[79]="ELIBACC  0x4f 0x..ffb1 Can not access a needed shared library";
m_map[80]="ELIBBAD  0x50 0x..ffb0 Accessing a corrupted shared library";
m_map[81]="ELIBSCN  0x51 0x..ffaf .lib section in a.out corrupted";
m_map[82]="ELIBMAX  0x52 0x..ffae Attempting to link in too many shared libraries";
m_map[83]="ELIBEXEC  0x53 0x..ffad Cannot exec a shared library directly";
m_map[84]="EILSEQ  0x54 0x..ffac Illegal byte sequence";
m_map[85]="ERESTART  0x55 0x..ffab Interrupted system call should be restarted";
m_map[86]="ESTRPIPE  0x56 0x..ffaa Streams pipe error";
m_map[87]="EUSERS  0x57 0x..ffa9 Too many users";
m_map[88]="ENOTSOCK  0x58 0x..ffa8 Socket operation on non-socket";
m_map[89]="EDESTADDRREQ  0x59 0x..ffa7 Destination address required";
m_map[90]="EMSGSIZE  0x5a 0x..ffa6 Message too long";
m_map[91]="EPROTOTYPE  0x5b 0x..ffa5 Protocol wrong type for socket";
m_map[92]="ENOPROTOOPT  0x5c 0x..ffa4 Protocol not available";
m_map[93]="EPROTONOSUPPORT  0x5d 0x..ffa3 Protocol not supported";
m_map[94]="ESOCKTNOSUPPORT  0x5e 0x..ffa2 Socket type not supported";
m_map[95]="EOPNOTSUPP  0x5f 0x..ffa1 Operation not supported on transport endpoint";
m_map[96]="EPFNOSUPPORT  0x60 0x..ffa0 Protocol family not supported";
m_map[97]="EAFNOSUPPORT  0x61 0x..ff9f Address family not supported by protocol";
m_map[98]="EADDRINUSE  0x62 0x..ff9e Address already in use";
m_map[99]="EADDRNOTAVAIL  0x63 0x..ff9d Cannot assign requested address";
m_map[100]="ENETDOWN  0x64 0x..ff9c Network is down";
m_map[101]="ENETUNREACH  0x65 0x..ff9b Network is unreachable";
m_map[102]="ENETRESET  0x66 0x..ff9a Network dropped connection because of reset";
m_map[103]="ECONNABORTED  0x67 0x..ff99 Software caused connection abort";
m_map[104]="ECONNRESET  0x68 0x..ff98 Connection reset by peer";
m_map[105]="ENOBUFS  0x69 0x..ff97 No buffer space available";
m_map[106]="EISCONN  0x6a 0x..ff96 Transport endpoint is already connected";
m_map[107]="ENOTCONN  0x6b 0x..ff95 Transport endpoint is not connected";
m_map[108]="ESHUTDOWN  0x6c 0x..ff94 Cannot send after transport endpoint shutdown";
m_map[109]="ETOOMANYREFS  0x6d 0x..ff93 Too many references: cannot splice";
m_map[110]="ETIMEDOUT  0x6e 0x..ff92 Connection timed out";
m_map[111]="ECONNREFUSED  0x6f 0x..ff91 Connection refused";
m_map[112]="EHOSTDOWN  0x70 0x..ff90 Host is down";
m_map[113]="EHOSTUNREACH  0x71 0x..ff8f No route to host";
m_map[114]="EALREADY  0x72 0x..ff8e Operation already in progress";
m_map[115]="EINPROGRESS  0x73 0x..ff8d Operation now in progress";
m_map[116]="ESTALE  0x74 0x..ff8c Stale NFS file handle";
m_map[117]="EUCLEAN  0x75 0x..ff8b Structure needs cleaning";
m_map[118]="ENOTNAM  0x76 0x..ff8a Not a XENIX named type file";
m_map[119]="ENAVAIL  0x77 0x..ff89 No XENIX semaphores available";
m_map[120]="EISNAM  0x78 0x..ff88 Is a named type file";
m_map[121]="EREMOTEIO  0x79 0x..ff87 Remote I/O error";
m_map[122]="EDQUOT  0x7a 0x..ff86 Quota exceeded";
m_map[123]="ENOMEDIUM  0x7b 0x..ff85 No medium found";
m_map[124]="EMEDIUMTYPE  0x7c 0x..ff84 Wrong medium type";
m_map[125]="ECANCELED  0x7d 0x..ff83 Operation Canceled";
m_map[126]="ENOKEY  0x7e 0x..ff82 Required key not available";
m_map[127]="EKEYEXPIRED  0x7f 0x..ff81 Key has expired";
m_map[128]="EKEYREVOKED  0x80 0x..ff80 Key has been revoked";
m_map[129]="EKEYREJECTED  0x81 0x..ff7f Key was rejected by service";
m_map[130]="EOWNERDEAD  0x82 0x..ff7e Owner died";
m_map[131]="ENOTRECOVERABLE  0x83 0x..ff7d State not recoverable";
m_map[132]="ERFKILL  0x84 0x..ff7c Operation not possible due to RF-kill";
m_map[133]="EHWPOISON  0x85 0x..ff7b Memory page has hardware error";
m_map[512]="ERESTARTSYS  0x200 0x..ff200";
m_map[513]="ERESTARTNOINTR  0x201 0x..ff1ff";
m_map[514]="ERESTARTNOHAND  0x202 0x..ff1fe restart if no handler..";
m_map[515]="ENOIOCTLCMD  0x203 0x..ff1fd No ioctl command";
m_map[516]="ERESTART_RESTARTBLOCK  0x204 0x..ff1fc restart by calling sys_restart_syscall";
m_map[521]="EBADHANDLE  0x209 0x..ff1f7 Illegal NFS file handle";
m_map[522]="ENOTSYNC  0x20a 0x..ff1f6 Update synchronization mismatch";
m_map[523]="EBADCOOKIE  0x20b 0x..ff1f5 Cookie is stale";
m_map[524]="ENOTSUPP  0x20c 0x..ff1f4 Operation is not supported";
m_map[525]="ETOOSMALL  0x20d 0x..ff1f3 Buffer or request is too small";
m_map[526]="ESERVERFAULT  0x20e 0x..ff1f2 An untranslatable error occurred";
m_map[527]="EBADTYPE  0x20f 0x..ff1f1 Type not supported by server";
m_map[528]="EJUKEBOX  0x210 0x..ff1f0 Request initiated, but will not complete before timeout";
m_map[529]="EIOCBQUEUED  0x211 0x..ff1ef iocb queued, will get completion event";
m_map[530]="EIOCBRETRY  0x212 0x..ff1ee iocb queued, will trigger a retry";

} // MakeMap
void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Init()
{
MakeMap();

} // Init



// MEMBERS
Map m_map;


}; // mjm_ya_errno

//////////////////////////////////////////////

template <class Tr>
class mjm_ya_errno_map : public std::map<typename Tr::StrTy, mjm_ya_errno< Tr > >  
{
 typedef mjm_ya_errno_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_ya_errno< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_ya_errno_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_ya_errno_map




////////////////////////////////////////////
#ifdef  TEST_MJM_YA_ERRNO
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_ya_errno <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;

#define CI(n) atoi(cip.wif(n).c_str()) 

void about()
{
Ss ss;
ss<<" MJM_YA_ERRNO "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;

#define CIP(n) atoi(cip.wif(n).c_str())
#define CFP(n) atof(cip.wif(n).c_str())

int main(int argc,char **args)
{
about();
typedef mjm_ya_errno<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="errono") {StrTy xxx=x.lerrno(CIP(1)); MM_ERR(MMPR2(CIP(1),xxx))  }
if (cmd=="test") {StrTy xxx=x.xxx_test(cip.p1,CIP(2)); MM_ERR(MMPR(xxx))  }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_YA_ERRNO_H__ 
